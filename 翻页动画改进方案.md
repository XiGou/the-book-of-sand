# 翻页动画改进方案

## 现状分析

当前实现使用**双页布局（spread）**，左右两页并排显示，通过 3D `rotateY` 模拟翻页。问题：
- 移动端体验差：双页在小屏幕上难以阅读
- 动画复杂：3D transform + 多层阴影 + 渐变叠加，性能开销大
- 视觉效果不够自然：3D 翻页在单屏上显得生硬

## 改进目标

1. **单页布局**：移动端友好，一屏一页
2. **交叉消除（cross-fade）**：新旧页面淡入淡出，过渡自然
3. **卷书页阴影**：模拟纸张卷曲时的阴影效果，增强真实感
4. **性能优化**：减少 3D transform，使用更轻量的 CSS 动画

## 技术方案

### 1. 布局改造

**从双页（spread）改为单页（single-page）**

```css
/* 当前：双页布局 */
.book-reader-spread {
  display: grid;
  grid-template-columns: 1fr 1fr; /* 左右两页 */
}

/* 改进：单页布局 */
.book-reader-page {
  width: 100%;
  max-width: 600px; /* 或使用 aspect-ratio 保持比例 */
  margin: 0 auto;
  position: relative;
}
```

### 2. 交叉消除动画

**使用 `opacity` + `transform` 实现淡入淡出**

```css
/* 页面容器 */
.page-container {
  position: relative;
  width: 100%;
  height: 100%;
}

/* 当前页 */
.page-current {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  opacity: 1;
  transition: opacity 0.4s ease-out, transform 0.4s ease-out;
}

/* 下一页（准备进入） */
.page-next {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  opacity: 0;
  transform: translateX(20px); /* 轻微右移，增强方向感 */
  transition: opacity 0.4s ease-in, transform 0.4s ease-in;
}

/* 上一页（准备进入） */
.page-prev {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  opacity: 0;
  transform: translateX(-20px); /* 轻微左移 */
  transition: opacity 0.4s ease-in, transform 0.4s ease-in;
}

/* 动画状态 */
.page-current.fade-out {
  opacity: 0;
  transform: translateX(-20px); /* 向左淡出 */
}

.page-next.fade-in {
  opacity: 1;
  transform: translateX(0);
}

.page-prev.fade-in {
  opacity: 1;
  transform: translateX(0);
}
```

### 3. 卷书页阴影效果

**使用多层 `box-shadow` + `clip-path` 模拟纸张卷曲**

```css
/* 页面基础样式 */
.page {
  background: var(--color-paper);
  box-shadow: 
    0 2px 8px rgba(0, 0, 0, 0.1),
    0 0 0 1px rgba(0, 0, 0, 0.05);
  position: relative;
}

/* 翻页时的阴影增强 */
.page-flipping {
  position: relative;
}

/* 模拟卷曲边缘的阴影 */
.page-flipping::before {
  content: '';
  position: absolute;
  top: 0;
  right: 0; /* 向右翻页时，右侧边缘 */
  width: 30px;
  height: 100%;
  background: linear-gradient(
    to left,
    rgba(0, 0, 0, 0.15) 0%,
    rgba(0, 0, 0, 0.08) 50%,
    transparent 100%
  );
  pointer-events: none;
  z-index: 10;
  animation: curl-shadow 0.4s ease-out;
}

/* 翻页动画中的动态阴影 */
@keyframes curl-shadow {
  0% {
    opacity: 0;
    width: 0;
  }
  50% {
    opacity: 1;
    width: 40px;
  }
  100% {
    opacity: 0;
    width: 0;
  }
}

/* 向左翻页时的左侧阴影 */
.page-flipping-prev::before {
  left: 0;
  right: auto;
  background: linear-gradient(
    to right,
    rgba(0, 0, 0, 0.15) 0%,
    rgba(0, 0, 0, 0.08) 50%,
    transparent 100%
  );
}
```

### 4. 组合方案：交叉消除 + 阴影

**完整的翻页效果**

```css
/* 页面容器 */
.page-wrapper {
  position: relative;
  width: 100%;
  min-height: 100%;
  overflow: hidden;
}

/* 当前页 */
.page-current {
  position: absolute;
  inset: 0;
  opacity: 1;
  z-index: 1;
  transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1),
              transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

/* 下一页 */
.page-next {
  position: absolute;
  inset: 0;
  opacity: 0;
  z-index: 2;
  transform: translateX(30px) scale(0.98);
  transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1),
              transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

/* 上一页 */
.page-prev {
  position: absolute;
  inset: 0;
  opacity: 0;
  z-index: 2;
  transform: translateX(-30px) scale(0.98);
  transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1),
              transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

/* 翻页动画 */
.page-current.flipping-out-next {
  opacity: 0;
  transform: translateX(-30px) scale(0.98);
}

.page-next.flipping-in {
  opacity: 1;
  transform: translateX(0) scale(1);
}

.page-current.flipping-out-prev {
  opacity: 0;
  transform: translateX(30px) scale(0.98);
}

.page-prev.flipping-in {
  opacity: 1;
  transform: translateX(0) scale(1);
}

/* 卷曲阴影（仅在翻页时显示） */
.page-next.flipping-in::before,
.page-prev.flipping-in::before {
  content: '';
  position: absolute;
  top: 0;
  width: 40px;
  height: 100%;
  background: linear-gradient(
    to left,
    rgba(0, 0, 0, 0.2) 0%,
    rgba(0, 0, 0, 0.1) 30%,
    transparent 100%
  );
  pointer-events: none;
  z-index: 10;
  animation: curl-edge 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

.page-prev.flipping-in::before {
  left: 0;
  right: auto;
  background: linear-gradient(
    to right,
    rgba(0, 0, 0, 0.2) 0%,
    rgba(0, 0, 0, 0.1) 30%,
    transparent 100%
  );
}

@keyframes curl-edge {
  0% {
    opacity: 0;
    width: 0;
  }
  50% {
    opacity: 1;
    width: 50px;
  }
  100% {
    opacity: 0;
    width: 0;
  }
}
```

## React 实现要点

### 状态管理

```typescript
const [currentPageIndex, setCurrentPageIndex] = useState(0);
const [flipState, setFlipState] = useState<'idle' | 'flipping-next' | 'flipping-prev'>(null);
const [nextPageContent, setNextPageContent] = useState(null);
```

### 翻页逻辑

```typescript
const goNext = () => {
  if (flipState !== 'idle') return;
  
  setFlipState('flipping-next');
  setNextPageContent(getPageContent(currentPageIndex + 1));
  
  // 触发动画
  setTimeout(() => {
    setCurrentPageIndex(prev => prev + 1);
    setFlipState('idle');
    setNextPageContent(null);
  }, 500); // 动画时长
};

const goPrev = () => {
  if (flipState !== 'idle') return;
  
  setFlipState('flipping-prev');
  setNextPageContent(getPageContent(currentPageIndex - 1));
  
  setTimeout(() => {
    setCurrentPageIndex(prev => prev - 1);
    setFlipState('idle');
    setNextPageContent(null);
  }, 500);
};
```

### JSX 结构

```tsx
<div className="page-wrapper">
  {/* 当前页 */}
  <div className={`page-current ${flipState === 'flipping-next' ? 'flipping-out-next' : flipState === 'flipping-prev' ? 'flipping-out-prev' : ''}`}>
    {getPageContent(currentPageIndex)}
  </div>
  
  {/* 下一页/上一页（仅在翻页时渲染） */}
  {flipState === 'flipping-next' && nextPageContent && (
    <div className="page-next flipping-in">
      {nextPageContent}
    </div>
  )}
  
  {flipState === 'flipping-prev' && nextPageContent && (
    <div className="page-prev flipping-in">
      {nextPageContent}
    </div>
  )}
</div>
```

## 移动端优化

1. **触摸手势**：支持左右滑动翻页
2. **响应式尺寸**：单页宽度自适应，最大宽度限制
3. **性能优化**：使用 `will-change` 提示浏览器优化
4. **减少重绘**：避免复杂的 3D transform

```css
.page-current,
.page-next,
.page-prev {
  will-change: opacity, transform;
}

/* 动画结束后移除 will-change */
.page-current:not(.flipping-out-next):not(.flipping-out-prev),
.page-next:not(.flipping-in),
.page-prev:not(.flipping-in) {
  will-change: auto;
}
```

## 优势总结

1. ✅ **移动端友好**：单页布局，阅读体验好
2. ✅ **性能更好**：2D transform + opacity，比 3D 轻量
3. ✅ **视觉效果自然**：交叉消除 + 阴影，模拟真实翻页
4. ✅ **实现简单**：CSS transition + React state，易于维护
5. ✅ **兼容性好**：不依赖 3D 特性，老设备也能流畅运行

## 实施步骤

1. 修改布局：从 `grid` 双列改为单页容器
2. 重构动画：移除 3D rotateY，改用 opacity + translateX
3. 添加阴影：实现卷曲边缘的渐变阴影
4. 更新 React 逻辑：简化状态管理，支持单页切换
5. 测试移动端：确保触摸手势和响应式布局正常
